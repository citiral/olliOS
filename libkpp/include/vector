//
// Created by Olivier on 25/09/16.
//

#ifndef OLLIOS_GIT_VECTOR_H
#define OLLIOS_GIT_VECTOR_H

#include "cstddef"
#include "utility"
#include <stdlib.h>
#include <new>

// divergence of spec from vector: No iterators, no allocator, missing functions

namespace std {
    template<class T>
    class vector {
    public:
        // typedefs
        using value_type = T;
        using size_type = std::size_t;

        vector() {
            _length = 0;
            _maxLength = 0;
            _data = nullptr;
        }

        ~vector() {
            // clean up all remaining elements
            for (int i = 0; i < _length ; i++) {
                _data[i].~T();
                free(_data);
            }
        }

        size_type size() const noexcept {
            return _length;
        }

        size_type max_size() const noexcept {
            return _maxLength;
        }

        size_t find(const T& value) const {
            for (int i = 0 ; i < _length ; i++) {
                if (_data[i] == value)
                    return i;
            }
            return -1;
        }

        void erase(size_t position) {
            // bubble all elements folowing the position one down
            while (position + 1 < _length) {
                _data[position] = std::move(_data[position + 1]);
                position++;
            }
            // and run the destructor of the last element, then shrink the array
            _data[position].~T();
            _length--;
        }

        T& at(size_type n) {
            return _data[n];
        }

        const T& at(size_type n) const {
            return _data[n];
        }

        T& operator[] (size_type n) {
            return _data[n];
        }

        const T& operator[] (size_type n) const {
            return _data[n];
        }

        void push_back(const value_type& val) {
            // optionally expand the array
            testExpand();
            // use placement new to construct the element at the end of the array
            //new (&_data[_length]) T(val);
            //_length++;
        }

        void push_back(value_type&& val) {
            // optionally expand the array
            testExpand();
            // use placement new to construct the element at the end of the array
            new (&_data[_length]) T(val);
            _length++;
        }

        void pop_back() {
            // first call the last elements constructor and then remove it
            if (_length > 0) {
                _data[_length-1]->~T();
                _length--;
            }
        }

        T& front() {
            return _data[0];
        }

        T&& front() const {
            return _data[0];
        }

        T& back() {
            return _data[_length-1];
        }

        T&& back() const {
            return _data[_length-1];
        }

    private:
        void testExpand() {
            if (_length == _maxLength) {
                printf("--EXPANDING: ");
                // get the new size and (re)allocate the array
                _maxLength = _maxLength*2 + 1;

                if (_data == nullptr) {
                    _data = static_cast<T*>(malloc(_maxLength * sizeof(T)));
                } else {
                    T*_datanew = static_cast<T*>(malloc(_maxLength * sizeof(T)));
                    for (int i = 0; i < _length ; i++) {
                        _datanew[i] = _data[i];
                    }
                    free(_data);
                    _datanew = _data;
                }
                printf("%X", _data);
            }
        }

        T* _data;
        size_t _length;
        size_t _maxLength;
    };

    template<class T>
    bool operator==( const vector<T>& lhs,
                     const vector<T>& rhs ) {
        if (lhs.size() != rhs.size())
           return false;

        for (int i = 0; i < lhs.size(); i++)
            if (!(lhs[i] == rhs[i]))
                return false;

        return true;
    };
}

#endif //OLLIOS_GIT_VECTOR_H
